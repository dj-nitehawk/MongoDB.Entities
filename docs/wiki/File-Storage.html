<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>GridFS alternative | MongoDB.Entities </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="GridFS alternative | MongoDB.Entities ">
      <meta name="description" content="A data access library for MongoDB with an elegant api, LINQ support and built-in entity relationship management.">
      
      <link rel="icon" href="../images/favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/icon.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="gridfs-alternative">GridFS alternative</h1>

<p>this library features a GridFS alternative where you can stream upload &amp; download files in chunks to keep memory usage at a minimum when dealing with large files. there is no limitation on the size or type of file you can store and the API is designed to be much simpler than GridFS.</p>
<h3 id="define-a-file-entity">Define a file entity</h3>
<p>inherit from <code>FileEntity&lt;T&gt;</code> abstract class instead of the usual <code>Entity</code> class for defining your file entities like below. You can add any other properties you wish to store with it.</p>
<pre><code class="lang-csharp">public class Picture : FileEntity&lt;Picture&gt;
{
    public string Title { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
}
</code></pre>
<p>the <code>FileEntity</code> is a sub class of <code>Entity</code> class. so all operations supported by the library can be performed with these file entities.</p>
<h3 id="upload-data">Upload data</h3>
<p>before uploading data for a file entity, you must save the file entity first. then simply call the upload method like below by supplying a stream object for it to read the data from:</p>
<pre><code class="lang-csharp">var kitty = new Picture
{
    Title = &quot;NiceKitty.jpg&quot;,
    Width = 4000,
    Height = 4000
};
await db.SaveAsync(kitty);

var stream = await new HttpClient().GetStreamAsync(&quot;https://placekitten.com/g/4000/4000&quot;);
using (stream)
{
    await kitty.Data(db).UploadAsync(stream);
}
</code></pre>
<p>the <code>Data()</code> method on the file entity gives you access to a couple of options for uploading and downloading. with those methods, you can specify <em>upload chunk size</em>, <em>download batch size</em>, <em>operation timeout period</em>, as well as <em>cancellation token</em> for controlling the process.</p>
<p>in addition to the properties you added, there will also be <code>FileSize</code>, <code>ChunkCount</code> &amp; <code>UploadSuccessful</code> properties on the file entity. the file size reports how much data has been read from the stream in bytes if the upload is still in progress or the total file size if the upload is complete. chunk count reports how many number of pieces the file has been broken into for storage. <em>UploadSuccessful</em> will only return true if the process completed without any issues.</p>
<h4 id="data-integrity-verification">Data integrity verification</h4>
<p>you have the option of specifying an MD5 hash when uploading and get mongodb to throw an <code>InvalidDataException</code> in case the data stream has got corrupted during the upload/transfer process. typically you'd calculate an MD5 hash value in your front-end/ui app before initiating the file upload and set it as a property value on the file entity like so:</p>
<pre><code class="lang-csharp">var kitty = new Picture
{
    Title = &quot;NiceKitty.jpg&quot;,
    Width = 4000,
    Height = 4000,
    MD5 = &quot;cccfa116f0acf41a217cbefbe34cd599&quot;
};
</code></pre>
<p>the <code>MD5</code> property comes from the base <code>FileEntity</code>. if a value has been set before calling <code>.Data().UploadAsync()</code> an MD5 hash will be calculated at the end of the upload process and matched against the MD5 hash you specified. if they don't match, an exception is thrown. so if specifying an MD5 for verification, you should always wrap your upload code in a try/catch block. if verification fails, the uploaded data is discarded and you'll have to re-attempt the upload.</p>
<h3 id="download-data">Download data</h3>
<pre><code class="lang-csharp">var picture = await db.Find&lt;Picture&gt;()
                      .Match(p =&gt; p.Title == &quot;NiceKitty.jpg&quot;)
                      .ExecuteSingleAsync();

using (var stream = File.OpenWrite(&quot;kitty.jpg&quot;))
{
    await picture.Data(db).DownloadAsync(stream);
}
</code></pre>
<p>first retrieve the file entity you want to work with and then call the <code>.Data(db).DownloadAsync()</code> method by supplying it a stream object to write the data to.</p>
<p>alternatively, if the ID of the file entity is known, you can avoid fetching the file entity from the database and access the data directly like so:</p>
<pre><code class="lang-csharp">await db.File&lt;Picture&gt;(&quot;FileID&quot;).DownloadAsync(stream);
</code></pre>
<h3 id="transaction-support">Transaction support</h3>
<p>uploading &amp; downloading file data within a transaction requires passing in a session to the upload and download methods. see <a href="Transactions.html#file-storage">here</a> for an example.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Developed by <a href='https://github.com/dj-nitehawk'>Đĵ ΝιΓΞΗΛψΚ</a> and <a href='https://github.com/dj-nitehawk/MongoDB.Entities/graphs/contributors'>contributors</a> / Licensed under <a href='https://github.com/dj-nitehawk/MongoDB.Entities/blob/master/LICENSE'>MIT</a> / Website generated by <a href='https://dotnet.github.io/docfx/'>DocFX</a>
        </div>
      </div>
    </footer>
  </body>
</html>
